package edu.illinois.cs.cs125.fuzzyjava

private const val EQUAL_TO = "equal to"
private const val GREATER_THAN = "greater than"
private const val GREATER_THAN_OR_EQUAL_TO = "greater than or equal to"
private const val LESS_THAN = "less than"
private const val LESS_THAN_OR_EQUAL_TO = "less than or equal to"
private const val NOT_EQUAL_TO = "not equal to"

/**
 * A class that takes the modifications from generating a variant and documents the code.
 */
class Documenter(private val documentationSource: String) {
    /**
     * The modifications from generating a variant.
     */
    private var modifications: MutableList<SourceModification> = mutableListOf()
    /**
     * The fuzzy tokens from which we generate docs.
     */
    private var tokens: MutableList<String> = mutableListOf()
    /**
     * Will concatenate the strings generated during inspection to create the JavaDoc.
     */
    private var javaDocBuilder = StringBuilder()

    /**
     * Retrieves the modifications generated by the [Fuzzer].
     *
     * @param modifications - The modifications that applied to the source.
     */
    fun addModifications(modifications: MutableList<SourceModification>) {
        this.modifications = modifications
    }

    /**
     * Generates descriptions of the modifications
     */
    fun inspectModifications(): String? {
        val inspectionsResults: MutableList<String> = mutableListOf() // Will contains descriptions of all of the modifications made to the original program

        val lineMap = HashMap<Int,MutableList<SourceModification>>() //Keeps track of variable on the same line Todo: Might have to change this when fuzzing entire blocks of code
        if (modifications.isEmpty()) {
            //return getDefaultDoc()
        }
        for (modification in modifications) {
            if (lineMap.containsKey(modification.startLine)) {
                lineMap[modification.startLine]?.add(modification)
            } else {
                lineMap[modification.startLine] = mutableListOf(modification)
            }
        }
        lineMap.values.forEach {
            line -> line.sortBy {  it.startColumn }
        }
        lineMap.values.forEach {
            for ((index, modification) in it.withIndex()) {
                val fuzzyToken = modification.content
                var message = "The fuzzy "
                message += when (fuzzyToken) {
                    FUZZY_COMPARISON -> "comparison: $fuzzyToken "
                    else -> {
                        // Todo: Don't forget to change this when you change how variable names are generated and make other elements fuzzable
                        "identifier: $fuzzyToken "
                    }
                }
                val difference = modification.endColumn - modification.replace.length
                message += "on line " + modification.startLine + " column " + difference + " was mapped to " + modification.replace + "."
                inspectionsResults.add(message)
                for (nextModificationIndex in index until it.size - 1) {
                    it[nextModificationIndex].startColumn -= difference //Todo: FIX THIS
                }
            }
        }

        val results = if (inspectionsResults.size == 0) "None..." else inspectionsResults.joinToString(separator = "\n* ")
        modifications.clear()
        inspectionsResults.clear()
        return results
    }

    fun getFuzzyTokens() {
        assert(documentationSource.contains("?"))
        var input = documentationSource.replaceBefore("?", "")
        var fuzzyToken = true
        var token = ""
        for ((index, char) in input.withIndex()) {
            if (char == '?') {
                fuzzyToken = true
            }
            if (fuzzyToken) {
                token += char
            } else {
                tokens.add(token)
                token = ""
                input = input.substring(index + 1)
                fuzzyToken = false
            }
        }

    }

    private fun getDoc(): List<String> {
        return tokens
    }

    private fun documentFeilds() {

    }

    private fun documentMethods() {

    }
}